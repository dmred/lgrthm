
████─████─█──█─████─█──█
█──█─█──█─█──█─█──█─█─█
█──█─█──█─█─██─█────██
█──█─█──█─██─█─█──█─█─█
█──█─████─█──█─████─█──█

████
█──██
████
█──██
████

███───██─█─█─████─█──█─█──█─█─█
█────█─█─█─█─█────█──█─█──█─█─█
█───█──█─███─████─█─██─████─███
█───█──█───█─█──█─██─█─█──█───█
█───█──█─███─████─█──█─█──█─███

void deepFind(Node node){
  Stack<Node> stack = new Stack<>();
  stack.add(node);
  Node TempNode;
  while(!stack.isEmpty){
    TempNode = stack.pop;
    TempNode.visit();
    for (Node node : TempNode.getNeighbours()){
      if (!node.isVisited())
      stack.add(node);
    }
  }
}


O(N+M), где N - колво вершин, M - колво ребер

_________________________________________________________________________________________________________________________________


████─████─███─████──███─████─█──█─█─█─███─█
█──█─█──█───█─█──██─█───█──█─█──█─█─█──█──█
████─████─███─████──███─████─████─███──█──████
█────█──█───█─█──██─█───█────█──█───█──█──█──█
█────█──█─███─████──███─█────█──█─███──█──████

────────────────────██──────────────██
──██─█──█─█──█─███─█──█─█──█─█───█─█──█
─█─█─█──█─█──█─█───█──█─█──█─█───█─█──█
█──█─█─██─████─███─█─██─████─███─█─█─██
█──█─██─█─█──█─█───██─█─█──█─█─█─█─██─█
█──█─█──█─█──█─███─█──█─█──█─███─█─█──█

─────────────────────────────────────────────────────██
████──███──█──█─████─████─████──████─███─█──█─█───█─█──█
█──█──█─█──█──█─█──█─█──█─█──██─█──█───█─█──█─█───█─█──█
█──█──█─█──████─█──█─█────████──████─███─████─███─█─█─██
█──█─█████─█──█─█──█─█──█─█──██──█─█───█─█──█─█─█─█─██─█
████─█───█─█──█─████─████─████───█─█─███─█──█─███─█─█──█


████─████─█──█─████─████─█──█
█──█─█──█─█──█─█──█─█──█─█─█
█────█──█─█─██─█────█──█─██
█──█─█──█─██─█─█──█─█──█─█─█
████─█──█─█──█─████─████─█──█


void reverse_list(node *&head, node *&current)
{
    current = head->next;
    head->next = NULL;
 
    while (current != NULL)
    {
        node *next = current->next;
        current->next = head->next;
        head->next = current;
        current = next;
    }
}

void reverse(Element * head){
  Element *previous = null;
  Element *current= head;
  Element *next ;
  while (next !=null){
    current.setNext(previous);
    current=next;
    next= current.next;  
  }
}
_______________________________________________________________________________________________________________________________
███─████─████─████──███─████─█──█─████
█──█─█──█─█──█─█──██─█───█──█─█─█──█──█
█──█─████─█──█─████──███─████─██───████
█──█─█────█──█─█──██─█───█────█─█──█──█
█──█─█────████─████──███─█────█──█─█──█


████─█──█─████─████─████─█──█─███─█──█
█──█─█─█──█──█─█────█──█─█──█─█───█─█
█────██───█──█─████─█──█─████─███─██
█──█─█─█──█──█─█──█─█──█────█─█───█─█
████─█──█─████─████─████────█─███─█──█

public bool brackets(String line){
Stack<char> stack = new Stack();

for (int i = 0; i<line.size();++i){
  switch(line.CharAt(i)){
    case "(" : {
      stack.add(line.charAt(i));
  }
  case ")" : {
    if (stack.isEmpty()){
      return false;
    } else {
      stack.pop();
    }
    break;
  }
  default : break;
}
}
if (stack.isEmpty()){
  
}
}
_______________________________________________________________________________________________________________________ 
